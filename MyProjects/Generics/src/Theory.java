public class Theory {
    /*
    #Обобщенные типы или дженерики (Generics)

    *Обобщенные типы позволяют писать код в рамках "неизвестных типов". То есть, программа не знает какого типа будут
    объекты с которыми она работает.

    * Проверка соответствия типов в Generic происходит ТОЛЬКО В МОМЕНТ КОМПИЛЯЦИИ,в момент запуска происходит
    "стирание типов" и все Generic  преобразуются в Object.


    ## Работа с обобщениями

    Определили интерфейс с неизвестным типом V, в качестве V может быть указан любой класс или параметр другого класса (
    см. ниже)
    public interface List<V> {
         void addToBegin(V value);
         }

    ##
    Мы говорим что класс LinkedList является параметризованным, то есть в качестве типа T можно подставить любой тип.
    Мы говорим, что наш класс должен имплементировать все методы интерфейса List.
    Но мы помним, что все методы интерфейса List обобщены типом V.
    Мы говорим что тип V во всех методах - это тот же самый тип который был подставлен в T.

    Класс Node как статический вложенный класс не зависит от обрамляющего типа LinkedList, поэтому у него своя
    параметризация буквой E

   Но поле top класса LinkedList - это экземпляр класса Node с уже подставленным типом T.

    public class LinkedList<T> implements List<T> {
    private Node<T> top;
    ...

    //говорим, что может работать с любым типом E
    private static class Node<E>{
        E value;
        ...
        public Node(E value ){
            this.value = value;
        }
    }

     */
}
