public class MainMethod {
    public static void main(String[] args) {
        /*
        Весь код который описывает метод, называется объявлением метода.
        Сигнатура метода включает название метода и типы параметров в определенном порядке

        Общий вид обьявления можно описать так:
        модификатор доступа, тип возвращаемого значение, имя метода (список параметров)
       {
        тело метода
        }

        1.Модификатор public - мы можем вызвать их из любого другого класса
        Модификатор отвечает за доступность/недоступность метода в других классах

        2.Ключевое слово static - Если он есть - то его необходимо указать после модификатора доступа.Если метод указан как
        static - это означает, что он может использоваться без ссылки на конкретный объект класса.

        3.Возвращаемое значение - если наш метод должен что то вернуть,то далее мы указываем тип возвращаемого значения:

        public String getName(){
        return name;
        } - в данном примере метод возвращает String

       Если метод ничего не возвращает  - вместо типа указывается ключевое слово - void

       public void wood(){
       System.out.println("Собака по имени " + name + " говорит гав - гав")
       }

       Перегрузка методов - Когда метод имеет одно и то же название но с разными параметрами

       public String myMethods(String name){
       тело метода
       }
       public String myMethods(String name, String firstname){
       тело метода
       }
       Что, если гостей будет трое? Конечно, мы можем еще раз перегрузить метод sayHi(), чтобы он принимал имена трех
       гостей. Но их ведь может быть и 4, и 5. И так до бесконечности.

Нет ли другого способа научить Джарвиса работать с любым количеством имен, без миллиона перегрузок метода sayHi()? :/

Конечно, есть! Иначе была бы разве Java самым популярным в мире языком программирования? ;)

public class Jarvis {

   public void sayHi(String...names) {

       for (String name: names) {
           System.out.println("Добрый вечер, " + name + ", как ваши дела?");
       }
   }

   public static void main(String[] args) {
       Jarvis jarvis = new Jarvis();
       jarvis.sayHi("Тони Старк");
       System.out.println();
       jarvis.sayHi("Тони Старк", "Капитан Америка");
   }
}

Запись (String...names) переданная в качестве параметра позволяет нам указать, что в метод передается какое-то
количество строк. Мы не оговариваем заранее сколько их должно быть, поэтому работа нашего метода становится теперь намного более гибкой:

public class Jarvis {

   public void sayHi(String...names) {

       for (String name: names) {
           System.out.println("Добрый вечер, " + name + ", как ваши дела?");
       }
   }

   public static void main(String[] args) {
       Jarvis jarvis = new Jarvis();
       jarvis.sayHi("Тони Старк", "Капитан Америка", "Черная Вдова", "Халк");
   }
}

Вывод в консоль:

Добрый вечер, Тони Старк, как ваши дела?
Добрый вечер, Капитан Америка, как ваши дела?
Добрый вечер, Черная Вдова, как ваши дела?
Добрый вечер, Халк, как ваши дела?

Внутри метода мы в числе перебираем все аргументы и выводим готовые фразы с именами на консоль.

Здесь мы применяем упрощенный цикл for-each (ты уже с ним сталкивался). Он отлично подходит, потому что запись
String...names — на самом деле означает, что все переданные параметры помещаются компилятором в массив.
Поэтому с переменной  names можно работать как с массивом, в том числе — перебирать в цикле.

При этом он сработает при любом количестве переданных строк! Две, десять, хоть тысяча — метод будет стабильно работать
с любым количеством гостей. Намного удобнее, чем делать перегрузки для всех возможных вариантов, согласен?:)

         */


    }
    public void sayHi(String...names){
        for (String name : names){
            System.out.println("Добрый вечер " + name);
        }
    }

}
